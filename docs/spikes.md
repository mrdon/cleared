# Cleared — Spike Plan

## Strategy

Validate the riskiest assumptions first. Each spike is 1-2 days. If a spike fails, we pivot before wasting effort on features.

```
Spike 1: Go ↔ Monty sandbox           ← existential risk     ✓ PASSED
Spike 2: LLM writes working agents    ← product risk          ✓ PASSED
Spike 3: Validation pipeline           ← safety risk           ✓ PASSED
Spike 4: End-to-end loop              ← integration risk      ✓ PASSED
────────────────────────────────────────────────────────
All spikes passed. Ready for feature development.
```

---

## Spike 1: Go ↔ Monty Sandbox — PASSED

**Question:** Can a Go binary execute Python scripts in Monty, inject Go primitives, and get results back?

**Why it was existential:** If Go can't talk to Monty, the entire architecture doesn't work.

### What we built

- A Python bridge (`spike1/bridge.py`) wrapping pydantic-monty with JSON-RPC 2.0 server/client
- A Go program (`spike1/main.go`) with bidirectional JSON-RPC — Go is both client (sends `run` requests) and server (handles primitive callbacks)
- Monty subprocess managed via `uv run python3 bridge.py`

### Key decisions made

- **No Go binding to Monty exists** (only Rust, Python/PyO3, JS/WASM). We use a Python subprocess.
- **JSON-RPC 2.0 over stdio** chosen over a custom protocol (same standard MCP uses)
- **Flat primitive names** (`journal_query`, not `journal.query`) — required by Monty's external_functions mechanism
- **uv** manages Python + pydantic-monty dependency
- **ID correlation** enables pipelining — multiple scripts can run concurrently over one bridge

### Communication protocol (validated)

```
Go → Bridge:  {"jsonrpc":"2.0","method":"run","params":{"script":"...","external_functions":["journal_query","config_get"]},"id":1}
Bridge → Go:  {"jsonrpc":"2.0","method":"journal_query","params":{"kwargs":{"status":"pending"}},"id":100}
Go → Bridge:  {"jsonrpc":"2.0","result":[{"id":"001","confidence":0.97}],"id":100}
Bridge → Go:  {"jsonrpc":"2.0","result":{"confirmed":1,"review":1},"id":1}
```

### Fallback plan (not needed, but retained for reference)

1. **Monty via Rust C FFI** → Go cgo bindings (investigated, complex)
2. **Restricted CPython subprocess** → JSON stdin/stdout, import filtering
3. **RustPython compiled to Wasm** → wazero (pure Go) — future single-binary path
4. **Starlark-go** → pure Go, limited Python subset (last resort)

### Bug found

`Response.Result` with `json:"result,omitempty"` drops null results, causing the bridge to not recognize the response and hang. Fixed by removing `omitempty` from the Result field.

### Success criteria
- [x] Go program successfully invokes Monty (via uv + Python subprocess)
- [x] Python script executes in sandbox
- [x] Primitive calls pause execution, flow to Go, return results
- [x] Sandbox prevents: file I/O, eval, exec, __import__
- [x] Round-trip latency < 100ms (**0.41ms/call** achieved)
- [ ] ~~Can bundle Monty in a distributable package~~ → requires uv + Python for now; WASM is future path

---

## Spike 2: LLM Writes Working Agents — PASSED

**Question:** Can an LLM reliably generate and modify Python agent scripts using our primitives?

**Also resolved:** Agent execution pattern — top-level scripts with flat primitives.

### What we built

- Complete primitives API as Python type stubs (`spike2/stubs.py`) — flat function signatures with type annotations
- System prompt (`spike2/system_prompt.txt`) describing: Monty constraints, all primitives, transaction shape, double-entry rules, agent format
- 4 test agents generated by Claude: Ingest, Learning, Modified Ingest, Fixed Ingest
- Validation runner (`spike2/test_in_monty.py`) — all 4 agents execute correctly in Monty

### Key findings

- **Top-level script pattern wins**: No `run(ctx)` wrapper, no imports, no classes. Primitives are global functions. Last expression is the output. LLMs generate this pattern reliably.
- **Type stubs alone are sufficient**: The LLM doesn't need examples — function signatures with type annotations are enough for correct primitive usage.
- **Monty's constraints simplify generation**: No try/except, no classes, no imports means fewer ways to go wrong.
- **Flat naming required**: Monty's external_functions are standalone names (`journal_add_double`), not `module.method`.

### Agent patterns evaluated

| Pattern | Verdict |
|---------|---------|
| Top-level script with flat primitives | **Winner** — simplest, LLMs generate reliably |
| `run(ctx)` function | Rejected — unnecessary wrapper, ctx not needed as primitives are globals |
| Event handlers | Rejected for agents — `ctx_emit()` used for inter-agent coordination instead |
| Pipeline composition | Rejected — Python control flow is clearer |

### Success criteria
- [x] LLM generates syntactically valid agent scripts >90% (4/4 = 100%)
- [x] Generated agents call primitives with correct argument types
- [x] LLM can modify existing agents without breaking them (Modified + Fixed agents both work)
- [x] Agent loop pattern identified (top-level scripts)
- [x] Type stubs are sufficient for the LLM to work without examples

---

## Spike 3: Validation Pipeline — PASSED

**Question:** Can we catch bad agent code before it runs?

### What we built

A 3-stage validation pipeline (`spike3/validate.py`):

1. **Static validation**: Monty's `type_check()` with primitive type stubs catches wrong arg types, missing params, undefined names. Plus string-based forbidden construct detection (open, eval, exec, __import__).
2. **Dry run**: Executes script with recording primitives (no real writes), checks invariants (balanced entries, valid accounts, valid statuses).
3. **Behavioral diff**: Runs old and new agent against same synthetic data, diffs primitive call counts and status distributions. Produces human-readable summary.

### Key findings

- **Monty's built-in `type_check()` replaces external linting** (ruff, mypy, etc.). It validates against our primitive stubs and catches type errors at parse time.
- **Dry run with recording primitives** is the most valuable stage — catches invariant violations (unbalanced entries, invalid accounts) that static analysis can't.
- **Behavioral diff** catches semantic changes (e.g., "auto-confirms everything now") that neither static nor dry-run catches.
- **Pipeline is fast**: ~15ms per full validation run.

### Test scenarios (all passed)

| Scenario | Stage | Result |
|----------|-------|--------|
| Forbidden constructs (open, eval, exec, __import__) | Static | BLOCKED |
| Wrong argument types | Static (type_check) | CAUGHT |
| Missing required args | Static (type_check) | CAUGHT |
| Unbalanced journal entries | Dry run | CAUGHT |
| Invalid account IDs | Dry run | CAUGHT |
| Invalid status values | Dry run | CAUGHT |
| Agent auto-confirms everything | Behavioral diff | FLAGGED |
| Good agent, no issues | Full pipeline | PASSED (no false positives) |

### Success criteria
- [x] Static validator catches forbidden Python constructs
- [x] Dry run detects invariant violations before real execution
- [x] Behavioral diff produces understandable summaries
- [x] Validation pipeline runs in < 5 seconds (**15ms/run** achieved)
- [x] False positive rate < 10% (0% in testing)

---

## Spike 4: End-to-End Loop — PASSED

**Question:** Does the full loop work together?

### What we built

Real Go primitives (`spike4/main.go`) wired to the Monty bridge from Spike 1:

- `importer_scan` — reads `import/` directory for new CSVs
- `importer_parse` — parses Chase CSV format (date conversion MM/DD/YYYY→YYYY-MM-DD)
- `importer_mark_processed` — moves files to `import/processed/`
- `journal_add_double` — writes balanced debit+credit legs to `YYYY/MM/journal.csv`
- `git_commit` — real `git add -A` + `git commit`
- `config_get`, `ctx_log`, `queue_add_review`, `rules_match`, etc.

Test data: 6 Chase checking transactions (`spike4/testdata/chase_checking.csv`) processed by a production-like ingest agent (`spike4/testdata/ingest.py`).

### Key findings

- **`journal_add_double` is the right primitive**: Always produces balanced entries by construction — one debit leg and one credit leg per call. Much safer than `journal_add` which could produce unbalanced entries.
- **Real git operations work**: `git add -A && git commit` with proper commit prefixes.
- **Date parsing matters**: Bank CSVs use MM/DD/YYYY, journal uses YYYY-MM-DD. Conversion done in the importer primitive.
- **Directory initialization** (`initRepo()`) creates the full repo structure, chart of accounts, rules, config, .gitignore, and initial git commit.

### Bug found

Same null result bug as Spike 1 (Go primitives returning `nil` caused JSON without `result` field). Fixed consistently.

### Success criteria
- [x] Init creates correct repo structure (accounts/, rules/, agents/, scripts/, templates/, tests/, logs/, import/processed/)
- [x] Agent executes in Monty sandbox
- [x] Agent calls Go primitives (importer, journal, git, rules, config, ctx, queue)
- [x] Transactions in journal.csv with correct double-entry format
- [x] All 6 invariants hold (balanced entries, valid accounts, dates within month, unique IDs)
- [x] Git commit with correct prefix message (`import: N transactions from M files`)
- [x] Agent log records actions (via ctx_log)
- [x] CSV moved to processed/
- [x] Full cycle < 10 seconds (**89ms** achieved)

---

## After Spikes

All 4 spikes passed. Feature development is low-risk execution:

| Priority | Feature |
|----------|---------|
| 1 | Full Go service layer (journal, accounts, importer, gitops) |
| 2 | More bank parsers, chart of accounts templates |
| 3 | Categorization rules engine |
| 4 | `cleared server` (swipe UI + chat) |
| 5 | Meta-agent (LLM writes/modifies agents via chat) |
| 6 | Self-improvement agents (learning, optimizer, tester, cleanup) |
| 7 | Reports + Excel export |
| 8 | Email/SMS notifications |
| 9 | Bootstrap import (historical data) |

### Recommendations from spikes

1. **Use a real JSON-RPC library** — We rolled our own for spikes; production should use a proper Go JSON-RPC 2.0 library.
2. **Consider `journal_add_double` as the only write primitive** — It's balanced by construction. Remove single-leg `journal_add` to prevent unbalanced entries at the API level.
3. **Invest in the bridge** — The Python bridge is the critical path. It needs proper error handling, graceful shutdown, health checks, and restart on crash.
4. **Plan the WASM migration path** — Current dependency on Python + uv is acceptable for now, but compiling Monty to WASM (via wazero) would enable a true single-binary distribution.
5. **Shared sub-scripts** — Learning agents should be able to create reusable Monty scripts in `scripts/` that other agents call, keeping core agents small.
